#!/usr/bin/env bash
# This script installs any specified starter project automatically

source ./lib/lib-utils.sh


PROJECT="$1"
VERSION="$2"
TIMEOUT="$3"

# Strings to be parsed for success in each output file
OSGI_STRING="Started"
SPRING_STRING="No issues found."
CDI_STRING="Content removed from location "
CDI_STRING2="Content removed from location "
GRADLE_STRING="No issues found."
QUARKUS_STRING="No issues found."
QUARKUS2_STRING="Atmosphere Framework "
QUARKUS3_STRING="Atmosphere Framework "
QUARKUS4_STRING="Atmosphere Framework "


SYSTEM=""
PORT=8080
FAIL_COUNT=0


usage(){
		echo -e "Usage: ./vaadin-stater-installer <project> <version> <timeout>
./vaadin-starter-installer --help for help"

		exit 1
}

# the help function provides you with a help menu
help_func(){

	echo -e "Usage: ./vaadin-stater-installer <project> <version> <timeout>

	Projects:

	base-starter-flow-osgi
	skeleton-starter-flow-cdi	
	base-starter-spring-gradle	
	vaadin-flow-karaf-example
	base-starter-flow-quarkus	
	skeleton-starter-flow-spring

	all - Run all the projects

	Example : ./vaadin-starter-installer base-starter-flow-osgi 23.1.0.rc2 200\n"


	exit 1

}

# checks and deletes old directory
check_directory(){
		[[ -d "$1" ]] && rm -rf "$1"
}

# kill the server
kill_server(){
		port="$1"
		if [[ "$SYSTEM" == "mac" ]]; then
				doKill $(lsof -t -i:$port) 2>/dev/null
		elif [[ "$SYSTEM" == "linux" ]]; then
				doKill $(fuser $port/tcp)
		else
				doKill $(ps | grep 'java' | awk '{print $1}')
		fi
}

# check the answer of "Do you wish to visually inspect it?"
check_code(){ 
		httpCode="$1"
		if [[ $httpCode -eq 0 ]]; then
				#ask "The server exited successfully. Press enter when ready."
				waitForUserWithBell "The server executed successfully. Inspect the server visually." 
				kill_server $PORT
		else	
				log "The server failed"
				FAIL_COUNT=$((FAIL_COUNT + 1))
				return 1
		fi
}

check_message(){

	message=$1
	if [[ "$message" -eq 0 ]]; then
			return 0
	else
			log "Failed to find the string in the output file."
			exit 1
	fi

}


fail(){

		cmd=$1
		output=$2

		log "$cmd failed! Output dumped to $output"

}	

# keep track of the number of errors
increment_fail(){

		FAIL_COUNT=$((FAIL_COUNT + 1))

}	

# display the number of errors (if any)
check_fail(){

				log "base_starter_flow_osgi failed $FAIL_COUNT time(s). Check osgi.output for errors."

}


git_clone(){
		git clone --quiet https://github.com/vaadin/$1.git
		cd "$1"
}

# Check what OS the user is using and store it in SYSTEM
check_os(){

	case $OSTYPE in
			darwin*) SYSTEM="mac";;
			Linux*) SYSTEM="linux";;
			*) SYSTEM="windows";;
	esac

}

mvn_clean_install(){

		mvn clean install >>../osgi.output 2>&1 || increment_fail

}

base_starter_flow_osgi(){

		log "Running $FUNCNAME"

		mvn_clean_install

		checkBusyPort $PORT || exit 1
		runInBackgroundToFile "java -jar app/target/app.jar" "osgi.output"
		waitUntilMessageInFile "osgi.output" "$OSGI_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		mvn versions:set-property -Dproperty=vaadin.version -DnewVersion=$VERSION >>../osgi.output 2>&1 || increment_fail

		mvn_clean_install
		
		checkBusyPort $PORT || exit 1
		runInBackgroundToFile "java -jar app/target/app.jar" "osgi.output"
		waitUntilMessageInFile "osgi.output" "$OSGI_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		mvn clean install -Dpnpm.enable=true >>../osgi.output 2>&1 || increment_fail

		checkBusyPort $PORT || exit 1
		runInBackgroundToFile "java -jar app/target/app.jar" "osgi.output"
		waitUntilMessageInFile "osgi.output" "$OSGI_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		log "$FUNCNAME: exited with $FAIL_COUNT error(s). Check the logs for more details."

		FAIL_COUNT=0
}

mvn_verify(){

		mvn verify -Pit,production >>../cdi.output 2>&1 || increment_fail

}

skeleton_starter_flow_cdi(){

		log "Running $FUNCNAME"


		checkBusyPort $PORT ||  exit 1
		runInBackgroundToFile "mvn wildfly:run" "cdi.output" 
		# TODO :  What to do here? We either check the exit status and increment FAIL_COUNT or something else
		# We can't check the exit status because killing the server might result in an error, besides
		# we are already checking that it works with waitUntilMessageInFile and checkHttpServlet

		waitUntilMessageInFile "cdi.output" "$CDI_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		mvn versions:set-property -Dproperty=vaadin.version -DnewVersion=$VERSION >>../cdi.output 2>&1 || increment_fail

		checkBusyPort $PORT || exit 1
		runInBackgroundToFile "mvn clean wildfly:run" "cdi.output"
		# TODO : The CDI_STRING2 appears twice in the output!
		waitUntilMessageInFile "cdi.output" "$CDI_STRING2" "$TIMEOUT" || kill_server $PORT
	 	messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"
		
		mvn clean wildfly:run -Dpnpm.enable=true || increment_fail

		log "$FUNCNAME: exited with $FAIL_COUNT error(s). Check the logs for more details."
			
		FAIL_COUNT=0
}

gradlew_boot(){

		./gradlew clean bootRun

}

base_starter_spring_gradle(){

		log "Running $FUNCNAME"

		checkBusyPort $PORT || exit 1
		runInBackgroundToFile "gradlew_boot" "gradle.output"
		waitUntilMessageInFile "gradle.output" "$GRADLE_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		perl -pi -e "s/vaadinVersion=.*/vaadinVersion=$VERSION/" gradle.properties


	# Edit the string and replacement string if they change in the future
	buildGradleString='mavenCentral\(\)'
	buildGradleReplace="mavenCentral\(\)\n\tmaven { setUrl('https:\/\/maven.vaadin.com\/vaadin-prereleases') }"

	perl -pi -e "s/$buildGradleString/$buildGradleReplace/" build.gradle


	# Edit the string and replacement string if they change in the future
	settingGradleString='pluginManagement {'
	settingGradleReplace="pluginManagement {\n  repositories {\n\tmaven { url = 'https:\/\/maven.vaadin.com\/vaadin-prereleases' }\n\tgradlePluginPortal()\n}"

	perl -pi -e "s/$settingGradleString/$settingGradleReplace/" settings.gradle

	checkBusyPort $PORT || exit 1
	runInBackgroundToFile "gradlew_boot" "gradle.output"
	waitUntilMessageInFile "gradle.output" "$GRADLE_STRING" "$TIMEOUT" || kill_server $PORT
	messageFound=$?
	check_message "$messageFound"
	checkHttpServlet "http://localhost:8080"
	httpCode=$?
	check_code "$httpCode"


}

mvn_install(){

		mvn install

}


remove_node-modules(){

	rm -rf ./main-ui/nodeModules

}

vaadin_flow_karaf_example(){

		log "Running $FUNCNAME"

		mvn_install

		mvn -pl main-ui install -Prun

		mvn versions:set-property -Dproperty=vaadin.version -DnewVersion=$VERSION

		mvn_install

		remove_node_modules && mvn install

		mvn -pl main-ui install -Prun

}


mvnw_package_production(){

		./mvnw package -Pproduction  >>../quarkus.output 2>&1 || increment_fail

}


base_starter_flow_quarkus(){

		log "Running $FUNCNAME"

		checkBusyPort $PORT || exit 1
		runInBackgroundToFile "./mvnw" "quarkus.output"
		waitUntilMessageInFile "quarkus.output" "$QUARKUS_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		mvnw_package_production
			
		checkBusyPort $PORT || exit 1
		runInBackgroundToFile " java -jar target/quarkus-app/quarkus-run.jar" "quarkus.output"
		waitUntilMessageInFile "quarkus.output" "$QUARKUS2_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"


		mvn versions:set-property -Dproperty=vaadin.version -DnewVersion=$VERSION >>../quarkus.output 2>&1 || increment_fail


		checkBusyPort $PORT || exit 1
		runInBackgroundToFile "./mvnw" "quarkus.output"
		waitUntilMessageInFile "quarkus.output" "$QUARKUS3_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		mvnw_package_production

		checkBusyPort $PORT || exit 1
		runInBackgroundToFile " java -jar target/quarkus-app/quarkus-run.jar" "quarkus.output"
		waitUntilMessageInFile "quarkus.output" "$QUARKUS4_STRING" "$TIMEOUT" || kill_server $PORT
		messageFound=$?
		check_message "$messageFound"
		checkHttpServlet "http://localhost:8080"
		httpCode=$?
		check_code "$httpCode"

		log "$FUNCNAME: exited with $FAIL_COUNT error(s). Check the logs for more details."

		FAIL_COUNT=0
}

mvn_package_production(){

		mvn package -Pproduction >>../spring.output 2>&1 || increment_fail

}

mvn_package_it(){

		mvn package -Pit >>../spring.output 2>&1 || increment_fail

}

skeleton_starter_flow_spring(){

	# Disable automatic browser startup in development mode
	# Doesn't work on Linux and Windows
	#turn_off_spring_browser


	log "Running $FUNCNAME"

	#change_spring_port
	checkBusyPort $PORT || exit 1
	runInBackgroundToFile mvn "spring.output"
	waitUntilMessageInFile "spring.output" "$SPRING_STRING" "$TIMEOUT" || kill_server $PORT
	messageFound=$?
	check_message "$messageFound"
	checkHttpServlet "http://localhost:8080"
	httpCode=$?
	check_code "$httpCode"

	mvn_package_production

	mvn_package_it

	mvn versions:set-property -Dproperty=vaadin.version -DnewVersion=$VERSION >>../quarkus.output 2>&1 || increment_fail

	checkBusyPort $PORT || exit 1
	runInBackgroundToFile mvn "spring.output"
	waitUntilMessageInFile "spring.output" "$SPRING_STRING" "$TIMEOUT" || kill_server $PORT
	messageFound=$?
	check_message "$messageFound"
	checkHttpServlet "http://localhost:8080"
	httpCode=$?
	check_code "$httpCode"

	rm -rf node_modules

	checkBusyPort $PORT || exit 1
	runInBackgroundToFile mvn "spring.output"
	waitUntilMessageInFile "spring.output" "$SPRING_STRING" "$TIMEOUT" || kill_server $PORT
	messageFound=$?
	check_message "$messageFound"
	checkHttpServlet "http://localhost:8080"
	httpCode=$?
	check_code "$httpCode"

	mvn_package_production

	mvn_package_it

	log "$FUNCNAME: exited with $FAIL_COUNT error(s). Check the logs for more details."

	FAIL_COUNT=0
}

# all runs all the projects
all(){

	# Check what OS the user is running
	check_os

  check_directory base-starter-flow-osgi
  git_clone base-starter-flow-osgi
  base_starter_flow_osgi
	cd ..

  check_directory skeleton-starter-flow-spring
  git_clone skeleton-starter-flow-spring
  skeleton_starter_flow_spring
	cd ..

  check_directory base-starter-spring-gradle
  git_clone base-starter-spring-gradle
  base_starter_spring_gradle
	cd ..

  check_directory base-starter-flow-quarkus
  git_clone base-starter-flow-quarkus
  base_starter_flow_quarkus
	cd ..

  check_directory skeleton-starter-flow-cdi
  git_clone skeleton-starter-flow-cdi
  skeleton_starter_flow_cdi
	cd ..

  check_directory vaadin-flow-karaf-example
  git_clone vaadin-flow-karaf-example
  vaadin_flow_karaf_example

	exit 0
}


# Search for the --debug option and act accordingly
for arg in $@
do
		if [[ "$arg" == "--debug" ]]; then
				PS4=""
				set -x	
		fi

		# TODO : https://stackoverflow.com/questions/25474854/after-using-exec-1file-how-can-i-stop-this-redirection-of-the-stdout-to-file
		# Make it so verbose outputs to stdout
		# We need a way of making redirections to files useless if we
		# provide the --verbose option
		if [[ "$arg" == "--verbose" ]]; then
	 			exec 1>/dev/tty 2>/dev/tty
		fi
done	

# If given --help or -h, call the help function
[[ "$1" == "--help" ]] || [[ "$1" == "-h" ]] && help_func

# If given less than three args, call the usage function
[[ "$#" -lt 3 ]] && usage

# If given all, run the all function
[[ "$1" == "all" ]] && all

# Convert my-chosen-project to my_chosen_project
func_name=${1//-/_}

# Check what OS the user is running
check_os

# Check if the directory already exists and delete it if necessary
check_directory "$PROJECT"

# Download the project(s)
git_clone "$PROJECT"

# Call the function
"$func_name"
